+++
date = "2020-07-05"
title = "Golang中的日期时间格式化"
slug = "time-fmt"
tags = ["time"]
categories = ["stdlib"]
+++

作为原Python开发，对Golang的日期时间格式化非常不适应。网上使用的格式化字符串例子大部分是这样的:

```go
import (
    "fmt"
    "time"
)

func main() {
    fmt.Println(time.Now().Format("2006-01-02 15:04:05"))
}
```

这样就可以说出格式化的时间字符串了。Golang用了`2006-01-02 15:04:05`这种写死时间来分辨时间格式，然后喜欢自由发挥的我自然就会这样加一句:

```go
fmt.Println(time.Now().Format("2020-01-02 15:04:05"))
```

和前面的例子唯一不同的是换了年份，但是这次的输出是:

```go
❯ go run simple.go
2020-07-05 09:38:45
5050-07-05 09:38:45
```

啊！下面的那个结果是错误的了。难道我只能用那个魔法字符串格式`2006-01-02 15:04:05`嘛？

带着这个问题开始寻找答案，首先从SO上找到了对这个时间的解释(就在src/time/format.go头部注释处):

```bash
// The reference time used in the layouts is the specific time:
//	Mon Jan 2 15:04:05 MST 2006
// which is Unix time 1136239445. Since MST is GMT-0700,
// the reference time can be thought of as
//	01/02 03:04:05PM '06 -0700
```

也就是说，这个时间按代表的部分拆开，其实可以理解为一个递增序列（01 02 03 04 05 06 07）

先感叹下语言设计者的用心：`2006-01-02 15:04:05`这个日期，不但挺好记的，而且用起来也比较方便。

那么问题2也出现了

### 为什么用下午三点而不是上午三点？

我盲猜是因为下午时间不能区分，所以写一段代码测试一下：


```go
t, _ := time.Parse("2006-01-02 15:04:05", "2006-01-02 03:04:05")

fmt.Println(t)
fmt.Println(t.Format("2006-01-02 03:04:05"))
fmt.Println(t.Format("2006-01-02 15:04:05"))

t, _ = time.Parse("2006-01-02 15:04:05", "2006-01-02 15:04:05")

fmt.Println(t)
fmt.Println(t.Format("2006-01-02 03:04:05"))
fmt.Println(t.Format("2006-01-02 15:04:05"))
```

这段代码分别把时间指向了`2006-01-02 03:04:05`和`2006-01-02 15:04:05`，然后格式化。看看输出:

```go
❯ go run simple.go
2006-01-02 03:04:05 +0000 UTC
2006-01-02 03:04:05
2006-01-02 03:04:05
2006-01-02 15:04:05 +0000 UTC
2006-01-02 03:04:05
2006-01-02 15:04:05
```

看到第二个例子了吧？这个是一个下午时间，但使用`2006-01-02 03:04:05`和`2006-01-02 15:04:05`格式化获得的时间是不一样的。所以可以看出一定要使用24小时制的时间。

### 延伸阅读

1. https://stackoverflow.com/questions/20530327/origin-of-mon-jan-2-150405-mst-2006-in-golang
```
